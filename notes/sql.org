#+title: SQL
#+startup: show2levels
* Table of Content :TOC:
- [[#structured-query-language-sql][Structured Query Language (SQL)]]
  - [[#basic][Basic]]
  - [[#data-types][Data Types]]
- [[#data-definition-language][Data Definition Language]]
  - [[#create][~CREATE~]]
  - [[#alter][~ALTER~]]
  - [[#drop][~DROP~]]
  - [[#rename][~RENAME~]]
  - [[#truncate][~TRUNCATE~]]
  - [[#constrains][Constrains]]
  - [[#other-useful-commands][Other Useful Commands]]
- [[#data-manipulation-language][Data Manipulation Language]]
  - [[#insert][~INSERT~]]
  - [[#delect][~DELECT~]]
  - [[#update][~UPDATE~]]
  - [[#select][~SELECT~]]
  - [[#merge][~MERGE~]]
- [[#data-control-language][Data Control Language]]
- [[#others][Others]]
  - [[#case][~CASE~]]
  - [[#execute][~EXECUTE~]]
  - [[#variables][Variables]]
  - [[#virtual-columns][Virtual Columns]]
- [[#useful-functions][Useful Functions]]
  - [[#decode][~DECODE()~]]
  - [[#nvl-or-ifnull][~NVL()~ or ~IFNULL()~]]
  - [[#substr-family][~SUBSTR()~ Family]]
- [[#footnotes][Footnotes]]

* Structured Query Language (SQL)
** Basic
1. All sentences are end with ~;~, break long sentences into multi lines to
increase the readabilities.
1. SQL is not case-sensitive, up-casing all keyword is recommend.
2. Comments:
   - Single line comments: ~-- Comments~ or ~# Comments~;
   - Multi line comments: ~/* Comments */~.
** Data Types
*** Numeric

| Type      | Storage (byte) |
|-----------+----------------|
| TINYINT   |              1 |
| SMALLINT  |              2 |
| MEDIUMINT |              3 |
| INT       |              4 |
| BIGINT    |              8 |
| FLOAT     |              4 |
| DOUBLE    |              8 |
| DECIMAL[fn:1] | ~              |

*Note*: Declare a non-negative number, such as non-negative int:
=INT UNSIGNED=

*** String

| Type     | Storage (byte) | Description |
|----------+----------------+-------------|
| CHAR     |          0-255 |             |
| VARCHAR  |        0-65535 |             |
| TINYBLOB |          0-255 | Binary      |
| TINYTEXT |          0-255 |             |

*Note*:
1. There are also normal, medium and long versions of blob and text.
2. There must be a parameter after string types' declarations to limit the
   max lengths of them, such as =char(10)= and =varchar(50)=.
*** Date and Time

| Type            | Storage | Format              |
|-----------------+---------+---------------------|
| DATE            |       3 | YYYY-MM-DD          |
| TIME            |       3 | HH:MM:SS            |
| YEAR            |       1 | YYYY                |
| DATETIME        |       8 | YYYY-MM-DD HH:MM:SS |
| TIMESTAMP[fn:2] |       4 | YYYY-MM-DD HH:MM:SS |

* Data Definition Language
** ~CREATE~
*** Create Table :Table:
The following statement demand SQL to create a new table with specified columns.

#+begin_src sql
CREATE TABLE tb_name
(
    col1 value_type1 GENERATED BY DEFAULT AS INDENTITY,
    col2 value_type2 NOT NULL,
    col3 value_type3 NULL DEFAULT default_value
    PRIMARY KEY (col1)
);
#+end_src

The first column will be generated by DBMS automatically and will be unique.

The field ~value_type~ specifies the type of value, here are some types

| Type               | Oracle       | MySQL     |
|--------------------+--------------+-----------|
| Fixed char list    | ~CHAR(n)~    | ~CHAR(n)~ |
| Variable char list | ~VARCHAR(n)~ | ~text(n)~ |

The field ~NOT NULL~ or ~NULL~ specifies whether the column can be ~NULL~ or
not, and the field ~DEFAULT default_value~ specifies the default value of the
column.
*** Identity Columns :Column:
The identity column is very useful for the surrogate primary key column.
When you insert a new row into the identity column, /Oracle/ auto-generates
and insert a sequential value into the column.

#+begin_src sql
GENERATED [ ALWAYS | BY DEFAULT [ ON NULL ] ]
AS IDENTITY [ ( identity_options ) ]
#+end_src

You can specify an option to generate identity values:

1. ~GENERATED ALWAYS~: ~Oracle~ always generates a value for the identity
   column. Attempt to insert a value into the identity column will cause an
   error.
2. ~GENERATED BY DEFAULT~: ~Oracle~ generates a value for the identity column
   if you provide no value. If you provide a value, /Oracle/ will insert that
   value into the identity column. For this option, /Oracle/ will issue an
   error if you insert a NULL value into the identity column.
3. ~GENERATED BY DEFAULT ON NULL~: /Oracle/ generates a value for the identity
   column if you provide a ~NULL~ value or no value at all.

There are also a number of options for the identity column.

1. ~START WITH initial_value~ controls the initial value to use for the
   identity column. The default initial value is ~1~.
2. ~INCREMENT BY internval_value~ defines the interval between generated
   values. By default, the interval value is ~1~.
3. ~CACHE~ defines a number of values that Oracle should generate beforehand
   to improve the performance. You use this option for the column that has
   a high number of inserts.

For example
#+begin_src sql
CREATE TABLE tb_name
(
    col1 value_type1 GENERATED BY DEFAULT AS INDENTITY,
    col2 value_type2 NOT NULL,
    col3 value_type3 NULL DEFAULT default_value
    PRIMARY KEY (col1)
);
#+end_src
*** ~CREATE TABLE AS SELECT~ :Table:
We can use ~CREATE TABLE AS SELECT~ statement to copy data from one table to another
table.

#+begin_src sql
CREATE TABLE new_table AS
SELECT * FROM tb;
#+end_src

*** Create View :View:
To create a view, use statement
#+begin_src sql
CREATE VIEW vw_name AS
SELECT select_statements;
#+end_src
*** Create Stored Procedure :Procedure:
**** /Oracle/
#+begin_src sql
CREATE PROCEDURE YourStoredProcedure (
param1 NUMBER
)
AS -- Or IS
/* declare variable here */
BEGIN
    /* SQL statements */
END;
#+end_src

The parameters can be declared as ~IN~, ~OUT~ or ~INOUT~, shows that whether
they are input parameter or output return value.

Keyword ~IS~ will be used, when the stored procedure in /Oracle/ is
nested into some other blocks. If the procedure is standalone then ~AS~
will be used. *Other than this coding standard, both have the same meaning*.

For example, a procedure returns the number of the rows in a table
#+begin_src sql
CREATE PROCEDURE ListCount (
    list_count OUT INTEGER)
IS
v_rows INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_rows
    FROM tb
    list_count := v_rows;
END;
#+end_src

Usage:
#+begin_src sql
var ReturnValue NUMBER
EXEC ListCount (:ReturnValue);
SELECT ReturnValue;
#+end_src

**** /MySQL/
#+begin_src sql
CREATE PROCEDURE ListCount (
    OUT list_count INT)
BEGIN
    SELECT COUNT(*) INTO list_count
    FROM tb
END;
#+end_src

Usage:
#+begin_src sql
CALL ListCount(@ReturnValue);
SELECT @ReturnValue;
#+end_src

** ~ALTER~
In ideal situation, we'll never use ~ALTER~ statements to alter the stucture
of a table. We should fully consider future needs in the design process of
a table.

*** Add Column
#+begin_src sql
ALTER TABLE tb_name
ADD col_name value_type;
#+end_src

*** Drop Column
#+begin_src sql
ALTER TABLE tb_name
DROP COLUMN col_name;
#+end_src

The process of dropping a column from a big table can be time and
resource-consuming. Therefore, we typically drop the column logically by
using the ~ALTER TABLE SET UNUSED COLUMN~ statement as follows:
#+begin_src sql
ALTER TABLE table_name
SET UNUSED COLUMN column_name;
ALTER TABLE table_name
DROP UNUSED COLUMNS;
#+end_src

*** Modify
#+begin_src sql
ALTER TABLE table_name
MODIFY (
    column_name_1 action,
    column_name_2 action,
    ...
);
#+end_src
** ~DROP~
*** Table
#+begin_src sql
DROP TABLE tb_name;
#+end_src
*** View
#+begin_src sql
DROP VIEW vw_name;
#+end_src

** ~RENAME~
In /Oracle/ and /MySQL/, use the following statement to rename a table
#+begin_src sql
RENAME TABLE
tb_name1 TO new_tb_name1,
tb_name2 TO new_tb_name2;
#+end_src

Or use
#+begin_src sql
ALTER TABLE old_tb RENAME new_tb;
#+end_src

However, ~ALTER TABLE~ can only rename one table at once.
** ~TRUNCATE~
When you want to delete all data from a table, you use the ~DELETE~ statement
without the ~WHERE~ clause as follows:
#+begin_src sql
DELETE FROM table_name;
#+end_src
when you have a table with a large number of rows, using the DELETE statement
to remove all data is not efficient.

/Oracle/ introduced the ~TRUNCATE TABLE~ statement that allows you to delete
all rows from a big table.

The following illustrates the syntax of the /Oracle/ ~TRUNCATE TABLE~ statement:
#+begin_src sql
TRUNCATE TABLE schema_name.table_name
[CASCADE]
[[ PRESERVE | PURGE] MATERIALIZED VIEW LOG ]]
[[ DROP | REUSE]] STORAGE ]
#+end_src

If a table has relationships with other tables via the foreign key constraints,
you need to use the ~CASCADE~ clause. Note that the ~TRUNCATE TABLE CASCADE~
statement requires the foreign key constraints defined with the
~ON DELETE CASCADE~ clause to work.

The ~MATERIALIZED VIEW LOG~ clause allows you to specify whether a materialized
view log defined on the table is to be preserved or purged when the table is
truncated. By default, the material view log is preserved.

The ~STORAGE~ clause allows you to choose either drop or reuse storage freed
by the truncated rows and associated indexes if any. By default, the storage
is dropped.

** Constrains
*** Add, Drop, Disable and Enable Constraint
Add constaint while creating table
#+begin_src sql
CREATE TABLE tb_name (
    CONSTRAINT cstrt_name cstrt_clause;
#+end_src

Add constaint into created table
#+begin_src sql
ALTER TABLE tb_name
ADD CONSTRAINT cstrt_name cstrt_clause;
#+end_src

Disable and Enable Constraint
#+begin_src sql
/* Disable */
ALTER TABLE tb_name
DISABLE CONSTRAINT cstrt_name;
/* Enable */
ALTER TABLE tb_name
ENABLE CONSTRAINT cstrt_name;
#+end_src
*** Primary Key
A *primary key* is a column of a combination of columns in a table that
uniquely identifies a row in the table.

The following are rules that make a column a primary key:

1. A primary key column cannot contain a NULL value or an empty string.
2. A primary key value must be unique within the entire table.
3. A primary key value should not be changed over time.

According to these rules, the following are the recommendations for the
primary keys:

1. The primary key should be meaningless.
2. The primary keys should be compact. The primary keys typically are
   numeric because Oracle typically processes numbers faster than any
   other data types.
3. It is considered a best practice have a primary key in every table
   though it is not mandatory in /Oracle/.

**** Add Primary Key When Create Tables
To create a primary key in a table, you use the ~PRIMARY KEY~ constraint.
For example

#+begin_src sql
CREATE TABLE tb_example (
    primary_key NUMBER PRIMARY KEY
);
#+end_src

**** Primary Key Clause
#+begin_src sql
CONSTRAINT constraint_name
PRIMARY KEY (column1, column2, ...)
#+end_src

*** Foreign Key
**** Create a Table with a Foreign Key
#+begin_src sql
CREATE TABLE child_table (
    ...
    CONSTRAINT fk_name
    FOREIGN KEY(col1, col2,...) REFERENCES parent_table(col1,col2)
    ON DELETE [ CASCADE | SET NULL ]
);
#+end_src

Use the ON DELETE clause to specify consequences when the rows in the
parent table are deleted.

1. ~ON DELETE CASCADE~: if a row in the parent is deleted, then all the
   rows in the child table that reference the removed row will be deleted.
2. ~ON DELETE SET NULL~: if a row in the parent is deleted, then all the
   rows in the child table reference the removed row will be set to ~NULL~
   for the foreign key columns.

Unlike the primary key constraint, a table may have more than one foreign
key constraint.

**** Foreign Key Clause
#+begin_src sql
CONSTRAINT fk_name
FOREIGN KEY (col1,col2) REFERENCES parent_table(col1,col2)
#+end_src

*** ~NOT NULL~
An /Oracle/ ~NOT NULL~ constraint specifies that a column cannot contain ~NULL~
values.
**** Create a Table with a ~NOT NULL~ Constraint
#+begin_src sql
CREATE TABLE table_name (
    ...
    column_name data_type NOT NULL
    ...
);
#+end_src
**** Drop ~NOT NULL~ constraints
#+begin_src sql
ALTER TABLE table_name MODIFY ( column_name NULL)
#+end_src
*** ~UNIQUE~
A unique constraint is an integrity constraint that ensures the data stored
in a column, or a group of columns, is unique among the rows in a table.
**** Create a Table with a Unique Constraint
#+begin_src sql
CREATE TABLE table_name (
    ...
    column_name data_type UNIQUE
    ...
);
#+end_src

**** Unique Clause
#+begin_src sql
CONSTRAINT unique_constraint_name UNIQUE(column_name)
#+end_src

*** ~CHECK~
An /Oracle/ check constraint allows you to enforce domain integrity by
limiting the values accepted by one or more columns.

To create a check constraint, you define a logical expression that returns
true or false. Oracle uses this expression to validate the data that is
being inserted or updated. If the expression evaluates to true, /Oracle/
accepts the data and carry the insert or update. Otherwise, /Oracle/ will
reject the data and does not insert or update at all.

**** Create Check Constraint
Typically, you create a check constraint on a column when you create the
table:
#+begin_src sql
CREATE TABLE table_name (
    ...
    column_name data_type CHECK (expression),
    ...
);
#+end_src

**** Check Clause
#+begin_src sql
CONSTRAINT check_constraint_name CHECK(expression);
#+end_src
** Other Useful Commands
*** Database Management
| Functions              | Commands                                |
|------------------------+-----------------------------------------|
| Show all databases     | =SHOW DATABASES;=                       |
| Show current databases | =SELECT DATABASE();=                    |
| Use/enter databases    | =USE name;=                             |

*** Table Management
| Functions                           | Commands                                               |
|-------------------------------------+--------------------------------------------------------|
| Show all tables in current database | =SHOW TABLES;=                                         |
| Show/describe table's structure     | =DESC table;=                                          |
| Show create command of one table    | =SHOW CREATE TABLE table;=                             |
| Create new table[fn:4]              | =CREATE TABLE table (...);=                            |
* Data Manipulation Language
** ~INSERT~
*** Insert full row into table
#+begin_src sql
INSERT INTO tb
VALUES(value1, value2, value3, value4);
#+end_src

The ~VALUES~ must contain all the values in one line.
*** Insert part of row into table
#+begin_src sql
INSERT INTO tb(col1, col2, col3, col4)
VALUES(value1, value2, value3, value4);
#+end_src

In this case, the ~VALUES~ can contain a part of the values in one line. And
other columns' values will be ~NULL~.
*** Insert the results of ~SELECT~
#+begin_src sql
INSERT INTO tb1(col1, col2, col3, col4)
SELECT col1, col2, col3, col4
FROM tb2;
#+end_src
*** ~INSERT INTO SELECT~
Sometimes we only need to copy a part of columns in a table, then use

#+begin_src sql
INSERT INTO tb1
SELECT col4, col5, col6
FROM tb2;
#+end_src

If the two tables have different columns' name
#+begin_src sql
INSERT INTO tb1 (
       col1, col2, col3
)
SELECT col4, col5, col6
FROM tb2;
#+end_src
*** ~INSERT ALL~ and ~INSERT FIRST~
**** Unconditional ~INSERT ALL~
#+begin_src sql
INSERT ALL
    INTO table_name(col1,col2,col3) VALUES(val1,val2, val3)
    INTO table_name(col1,col2,col3) VALUES(val4,val5, val6)
    INTO table_name(col1,col2,col3) VALUES(val7,val8, val9)
Subquery;
#+end_src

The ~Subquery~ usually be ~SELECT 1 FROM DUAL~.

**** Conditional ~INSERT ALL~ and ~INSERT FIRST~
#+begin_src sql
INSERT [ ALL | FIRST ]
    WHEN condition1 THEN
        INTO table_1 (column_list ) VALUES (value_list)
    WHEN condition2 THEN
        INTO table_2(column_list ) VALUES (value_list)
    ELSE
        INTO table_3(column_list ) VALUES (value_list)
Subquery
#+end_src

~INSERT ALL~ example:
#+begin_src sql
INSERT ALL
   WHEN amount < 10000 THEN
      INTO small_orders
   WHEN amount >= 10000 AND amount <= 30000 THEN
      INTO medium_orders
   /* Or use ELSE */
   WHEN amount > 30000 THEN
      INTO big_orders

  SELECT order_id,
         customer_id,
         (quantity * unit_price) amount
  FROM orders
  INNER JOIN order_items USING(order_id);
#+end_src

~INSERT FIRST~ example:
#+begin_src sql
INSERT FIRST
    WHEN amount > 30000 THEN
        INTO big_orders
    WHEN amount >= 10000 THEN
        INTO medium_orders
    WHEN amount > 0 THEN
        INTO small_orders
 SELECT order_id,
         customer_id,
         (quantity * unit_price) amount
 FROM orders
 INNER JOIN order_items USING(order_id);
#+end_src

These two example above have the same functions.

** ~DELECT~
#+begin_src sql
DELETE FROM tb
WHERE condition;
#+end_src

If you want to delete all the data in one table, use ~TRUNCATE TABLE~ instead.
** ~UPDATE~
#+begin_src sql
UPDATE tb
SET col1 = value1,
    col2 = value2
WHERE condition;
#+end_src

If there is no condition in this statement, the DBMS will update all the date
in the table.
** ~SELECT~
#+begin_src sql
SELECT column_1 AS alias_1, column_2 AS alias_2
FROM your_table;
#+end_src

This will return two columns of data, ~column_1~ and ~column_2~ sliced from
~your_table~, and will give them alias respectively: ~column_1~ as ~alias_1~ and
~column_2~ as ~alias_2~.

*Note*: There is no ~AS~ keyword in /Oracle/.

If you want to get all the columns from the table, use ~*~ instead of the names
of columns. Such as

#+begin_src sql
SELECT * FROM your_table;
#+end_src

~DUAL~ is a one-row, one-column built-in table in SQL. It is used to hold the
results of a ~SELECT~ statement that are otherwise not stored or used. The
results in the ~DUAL~ table can also be manipulated per the end-user
requirements.

The following is the order must to be followed.

1. ~SELECT~
2. ~FROM~
3. ~WHERE~
4. ~GROUP BY~
5. ~HAVING~
6. ~ORDER BY~

*** Select Distinct Values
If you want to select the distinct values in one column, use

#+begin_src sql
SELECT DISTINCT your_column FROM your_table;
#+end_src

*Note*: The keyword ~DISTINCT~ will be applied to all columns, that is, if you
use

#+begin_src sql
SELECT DISTINCT column_1, column_2 FROM your_table;
#+end_src

only the columns with the same values of ~column_1~ and ~column_2~ will be
ignored.

*** Limit the Results
The result of a query may be too large to read, if you want to restrict the number
of lines the query returns, use the following methods:

**** Oracle
#+begin_src sql
SELECT your_column FROM your_table
OFFSET your_offset ROWS
FETCH NEXT your_row_count ROWS ONLY;
#+end_src

~your_row_count~ can be replaced with ~your_percentage PERCENT~.

~ONLY~ can be replaced with ~WITH TIES~.The ~WITH TIES~ returns additional
rows with the same sort key as the last row fetched. Note that if you use
WITH TIES, you must specify an ORDER BY clause in the query. If you don’t,
the query will not return the additional rows.
**** SQL Server and Access
#+begin_src sql
SELECT TOP 5 your_column
FROM your_table;
#+end_src

**** DB2
#+begin_src sql
SELECT your_column FROM your_table
FETCH FIRST 5 ROWS ONLY;
#+end_src

**** MySQL, MariaDB, PostgreSQL SQLite...
#+begin_src sql
SELECT your_column FROM your_table
LIMIT 5;
#+end_src

Also, in these DBMS'es, we can set offset value:
#+begin_src sql
SELECT your_column FROM your_table
LIMIT 5 OFFSET 10;
#+end_src

Or on MySQL and MariaDB
#+begin_src sql
SELECT your_column FROM your_table
LIMIT 5 10;
#+end_src
*** Sort the Results
To sort the values returned by a query statement, use the keyword ~ORDER BY~:

#+begin_src sql
SELECT column_1, column_2, column_3
FROM your_table
ORDER BY column_1, column_2 DESC;
#+end_src

This means sort the values by ~column_1~ in ascending order, and *then* by ~column_2~
in descending order.
*** Filter
**** ~WHERE~
In ~SELECT~ statements, we use ~WHERE~ clause to filter the data and get
the ones we need.

#+begin_src sql
SELECT product_name, product_price
FROM tb_products
WHERE product_price <= 3.99
ORDER BY product_price DESC;
#+end_src

*Note*: the ~ORDER BY~ clause must be after the ~WHERE~ clause.

***** Condition Operators
| Operator          | Description              |
|-------------------+--------------------------|
| ~=~               | equal to                 |
| ~<>~              | not equal to             |
| ~!=~              | not equal to             |
| ~>~               | greater than             |
| ~>=~              | greater than or equal to |
| ~<~               | less than                |
| ~<=~              | less than or equal to    |
| ~BETWEEN a AND b~ | Omitted                  |
| ~IS NULL~         | Omitted                  |

There are another operator: ~IN~, this judges that if the values is in the
given value set.

#+begin_src sql
SELECT product_name, product_price
FROM tb_products
WHERE product_name IN ('Name 1', 'Name 2', 'Name 3')
ORDER BY product_price DESC;
#+end_src
***** Logical Operators
There are three logical operators: ~AND~, ~OR~ and ~NOT~. Their usage is
obvious. Note that the priority of ~AND~ is higher than ~OR~.
**** ~LIKE~
In search pattern, the wildcard ~%~ means any charactor appears arbitrarily.
The wildcard ~_~ means any charactor appears one time.

*Note*: In *Microsoft Access*, use ~*~ instead of ~%~ and ~?~ instead of ~_~.
DB2 does'nt support the wildcard ~_~.

There is another wildcard, ~[]~, this means the charactor must be one of the
charactors in ~[]~. For example, find words starting with "A" or "B", use
pattern ~[AB]%~.

If add a ~^~ in ~[]~, the wildcard will search charactor not
in ~[]~. For example, find words not starting with "A", "B" and "C", use
pattern ~[^ABC]%~.

*Note*, In *Microsoft Access*, use ~!~ instead of ~^~.
*** Calculation Field
**** Concatenate Field
To concatenate two columns into one column, use concatenating operator:
~+~ in /Access/ and /SQL Server/, ~||~ in /DB2/, /Oracle/, /PostgreSQL/,
/SQLite/ and /Open Office Base/. There is no operator in /MySQL/ and /MariaDB/,
we have to use some special functions to achieve this.

For example, if we need to concatenate ~country~ and ~enterprise_name~ into one
field like ~enterprise_name (country)~, use

#+begin_src sql
SELECT enterprise_name + ' (' + country + ')'
       AS enterprise_title
FROM your_table
ORDER BY enterprise_name;
#+end_src

Note that all the string field have a few spaces on their right, to remove
them, use function ~RTRIM()~:

#+begin_src sql
SELECT RTRIM(enterprise_name) || ' (' + RTRIM(country) || ')'
       AS enterprise_title
FROM your_table
ORDER BY enterprise_name;
#+end_src

There are also ~LTRIM()~ to remove spaces on left and ~TRIM()~ for both
sides.

**** Algorithm Calculation
For example, to calculate the total prise

#+begin_src sql
SELECT price * amount AS total_prise
FROM your_table
ORDER BY total_prise;
#+end_src
*** Functions
**** Text Functions
| Function                                | Description                                |
|-----------------------------------------+--------------------------------------------|
| ~LEFT()~                                | Return charactors on the left of a string  |
| ~RIGHT()~                               | return charactors on the right of a string |
| ~LENGTH()~ or ~DATALENGTH()~ or ~LEN()~ | Return the length of a string              |
| ~LOWER()~ or ~LCASE()~ for /Access/     | Return the lower case of a string          |
| ~UPPER()~ or ~UCASE()~ for /Access/     | Return the upper case of a string          |
| ~LTRIM()~                               | Remove spaces on the left of the string    |
| ~RTRIM()~                               | Remove spaces on the right of the string   |
| ~TRIM()~                                | Remove spaces on both sides of the string  |
| ~SOUNDEX()~                             | Return the soundex value of a string       |
**** Date and Time Functions
Different DBMS'es have different functions for date and time process. The
following are functions for /MySQL/ and /Oracle/.
***** MySQL
| Function     | Description                                         | Synonyms and other implementations    |
|--------------+-----------------------------------------------------+---------------------------------------|
| ~NOW()~      | Return the current date and time                    | ~CURRENT_TIMESTAMP()~, ~LOCAL_TIME()~ |
| ~CURDATE()~  | Return the current date                             | ~CURRENT_DATE()~                      |
| ~CURTIME()~  | Return the current time                             | ~CURRENT_TIME()~                      |
| ~EXTRACT()~  | Extract part of a date                              |                                       |
| ~DATE()~     | Extract the date part of a date/datetime expression |                                       |
| ~TIME()~     | Extract the time part of a date/datetime expression |                                       |
| ~YEAR()~     | Extract the year                                    | ~EXTRACT(YEAR FROM date)~             |
| ~MONTH()~    | Extract the month                                   | ~EXTRACT(MONTH FROM date)~            |
| ~WEEK()~     | Extract the week number                             | ~EXTRACT(WEEK FROM date)~             |
| ~DAY()~      | Extract the day                                     | ~EXTRACT(DAY FROM date)~              |
| ~HOUR()~     | Extract the hour                                    | ~EXTRACT(HOUR FROM date)~             |
| ~MINUTE()~   | Extract the minute                                  | ~EXTRACT(MINUTE FROM date)~           |
| ~SECOND()~   | Extract the second                                  | ~EXTRACT(SECOND FROM date)~           |
| ~LAST_DAY()~ | Return the last day of the month for the argument   |                                       |

***** Oracle
| Function         | Description                                                                      |
|------------------+----------------------------------------------------------------------------------|
| ~EXTRACT()~      | Extract part of a date                                                           |
| ~CURRENT_DATE()~ | Return the current date and time in the session time zone                        |
| ~LAST_DAY()~     | Return the last day of the month for the argument                                |
| ~TO_DATE~        | Convert a date which is in the character string to a DATE value.                 |
| ~TO_CHAR()~      | Convert a DATE or an INTERVAL value to a character string in a specified format. |
**** Aggregate Functions
| Function  | Description                              |
|-----------+------------------------------------------|
| ~AVG()~   | Return the average of one column         |
| ~COUNT()~ | Return the number of lines of one column |
| ~MAX()~   | Return the maximum of one column         |
| ~MIN()~   | Return the minimum of one column         |
| ~SUM()~   | Return the sum of one column             |

*Note*: All the functions above can use the keyword ~DISTINCT~.
*** Group Data
**** Create Groups
To divide data into different groups by some rules, use clause ~GROUP BY~,
for example

#+begin_src sql
SELECT company_id, COUNT(*) AS num_products
FROM tb_products
GROUP BY company_id;
#+end_src

this'll return the number of products of different company.
**** Filter Groups
To filter the groups we obtain, use clause ~HAVING~, for example

#+begin_src sql
SELECT company_id, COUNT(*) AS num_products
FROM tb_products
GROUP BY company_id
HAVING COUNT(*) >= 2;
#+end_src

this'll return the number of products of different company greater than 2.

*Note*: ~WHERE~ is used to filter the data we want, ~HAVING~ is used to
filter the groups we obtain. ~WHERE~ will be executed before ~GROUP BY~,
and then, also before ~HAVING~.
**** ~GROUPING SETS~
A ~GROUPING SETS~ expression allows you to selectively define one or more
grouping sets in a query. For example
#+begin_src sql
SELECT
    customer,
    category,
    SUM(sales_amount)
FROM
    customer_category_sales
GROUP BY
    GROUPING SETS(
        (customer,category),
        (customer),
        (category),
        ()
    )
ORDER BY
    customer,
    category;
#+end_src

This query is similar to the following but neater and easier to maintain.
#+begin_src sql
SELECT
    category,
    NULL,
    SUM(sales_amount)
FROM
    customer_category_sales
GROUP BY
    category
UNION ALL
SELECT
    customer,
    NULL,
    SUM(sales_amount)
FROM
    customer_category_sales
GROUP BY
    customer
UNION ALL
SELECT
    customer,
    category,
    sum(sales_amount)
FROM
    customer_category_sales
GROUP BY
    customer,
    category
UNION ALL
SELECT
    NULL,
    NULL,
    SUM(sales_amount)
FROM
    customer_category_sales;
#+end_src

**** ~GROUPING~ and ~GROUPING ID~
Use ~GROUPING~ to differentiates the super-aggregate rows from regular
grouped rows
#+begin_src sql
SELECT
    DECODE(GROUPING(customer),1,'ALL customers', customer) customer,
    DECODE(GROUPING(category),1,'ALL categories', category) category,
    SUM(sales_amount)
FROM
    customer_category_sales
GROUP BY
    GROUPING SETS(
        (customer,category),
        (customer),
        (CATEGORY),
        ()
    )
ORDER BY
    customer,
    category;
#+end_src

Similarly, the ~GROUPING_ID()~ function takes the “group by” columns and
returns a number denoting the ~GROUP BY~ level. In other words, it
provides another compact way to identify the subtotal rows.
#+begin_src sql
SELECT
    customer,
    category,
    GROUPING_ID(customer,category) grouping,
    SUM(sales_amount)
FROM customer_category_sales
GROUP BY
    GROUPING SETS(
        (customer,category),
        (customer),
        (category),
        ()
    )
ORDER BY
    customer,
    category;
#+end_src
**** ~CUBE~ and ~ROLLUP~
Use ~CUBE~ to generate all possible combinations of given dimention
#+begin_src sql
SELECT col1, col2, SUM(col3)
FROM tb_name
GROUP BY
      CUBE (
           col1, col2);
#+end_src

This will return all the ~2^n~ possible combinations, and the result is the
same as

#+begin_src sql
SELECT col1, col2, SUM(col3)
FROM tb_name
GROUP BY
      GROUPING SETS (
        (col1, col2),
        (col1),
        (col2),
        ()
      )
#+end_src

~ROLLUP~ generate another kind of ~GROUPING SETS~
#+begin_src sql
SELECT col1, col2, col3, AVG(col4)
FROM tb_name
GROUP BY
        ROLLUP (col1, col2, col3);
#+end_src

This is similar to
#+begin_src sql
SELECT col1, col2, col3, AVG(col4)
FROM tb_name
GROUP BY
        GROUPING SETS (
            (col1, col2, col3),
            (col1, col2),
            (col1),
            ()
        )
#+end_src

but the order will be different.
**** ~PIVOT~ and ~UNPIVOT~ :TODO:

*** ~JOIN~
**** Cartesian Product (Cross Join)
The following SQL will return Cartesian product of two table

#+begin_src sql
SELECT tb_1.col1, tb_1.col2, tb_2.col1
FROM tb_1, tb_2;
#+end_src

Or
#+begin_src sql
SELECT tb_1.col1, tb_1.col2, tb_2.col1
FROM tb_1 CROSS JOIN tb_2;
#+end_src

We can use ~WHERE~ clause to filter the results
#+begin_src sql
SELECT tb_1.col1, tb_1.col2, tb_2.col1
FROM tb_1, tb_2
WHERE tb_1.col1 = tb_2.col1;
#+end_src

Note that Cartesian product does not have the ~ON~ clause with a join
predicate.

**** ~INNER JOIN~
We can use ~INNER JOIN~ to obtain the result of [[*Cartesian Product][Cartesian Product]]:

#+begin_src sql
SELECT tb_1.col1, tb_1.col2, tb_2.col1
FROM tb_1 INNER JOIN tb_2
     ON tb_1.col1 = tb_2.col1
#+end_src

Inner join means get all the data satisfy the condition.

We can also use alias for table, such as
#+begin_src sql
SELECT t1.col1, t1.col2, t2.col1
FROM tb_1 AS t1 INNER JOIN tb_2 AS t2
     ON t1.col1 = t2.col1
#+end_src

Besides the ~ON~ clause, it's possible to use the ~USING~ clause to specify
which columns to test for equality when joining tables. For example
#+begin_src sql

SELECT t1.col1, t1.col2, t2.col1
FROM tb_1 AS t1 INNER JOIN tb_2 AS t2
     USING (col1, col2);
#+end_src

Note that the columns listed in the ~USING~ clause must be available in
both ~tb_1~ and ~tb_2~.

**** Self-Join
Self-join is a special kind of inner join, for example

#+begin_src sql
SELECT c1.customer_id, c1.customer_name, c1.customer_contact
FROM tb_customers AS c1, tb_customers AS c2
WHERE c1.customer_name = c2.customer_name
      AND c2.customer_contact = "Jim Jones";
#+end_src

**** ~OUTER JOIN~
Sometimes we need data without association with the data in the other table,
in this case, we use ~OUTER JOIN~

There are three kinds of ~OUTER JOIN~: ~LEFT OUTER JOIN~, ~RIGHT OUTER JOIN~
and ~FULL OUTER JOIN~.

~LEFT OUTER JOIN~ contains data returned by ~INNER JOIN~ and all the data
in the table on the left side of the keyword.

#+begin_src sql
SELECT c.customer_id, o.order_num
FROM tb_customer AS c LEFT OUTER JOIN tb_order AS o
     ON c.customer_id = o.customer_id;
#+end_src

This will return all the customers and their orders and those people without
any order.

Respectively, ~RIGHT OUTER JOIN~ contains data returned by ~INNER JOIN~ and
all the data in the table on the right side of the keyword. ~FULL OUTER JOIN~
returns all the data of both tables and combine them.

*Note*: /Access/, /MariaDB/, /MySQL/, /SQLite/ and /Open Office Base/ don't
support ~FULL OUTER JOIN~.

We can use ~LEFT JOIN~ instead of ~LEFT OUTER JOIN~ and respectively ~RIGHT JOIN~
instead of ~RIGHT OUTER JOIN~.
*** Set Operators
We can use keyword ~UNION~ to get the union of two query, for example

#+begin_src sql
SELECT col1, col2, col3
FROM tb1
WHERE condition1
UNION
SELECT col1, col2, col3
FROM tb1
WHERE condition2
UNION
SELECT col1, col2, col3
FROM tb2
WHERE condition3;
#+end_src

~UNION~ will automatically replace duplacated data, if you want to keep them,
use ~UNION ALL~ instead of ~UNION~.

There can be one ~ORDER BY~ clause at the end of ~UNION~ to sort the data.

Similarly, ~INTERSECT~ compares the result of two queries and returns the
distinct rows that are output by both queries. ~MINUS~ compares two queries
and returns distinct rows from the first query that are not output by the
second query.
** ~MERGE~
The /Oracle/ ~MERGE~ statement selects data from one or more source tables
and updates or inserts it into a target table. The ~MERGE~ statement allows
you to specify a condition to determine whether to update data from or insert
data into the target table.

The following illustrates the syntax of the Oracle ~MERGE~ statement:

#+begin_src sql
MERGE INTO target_table
USING source_table
ON search_condition
    WHEN MATCHED THEN
        UPDATE SET col1 = value1, col2 = value2,...
        WHERE <update_condition>
        [DELETE WHERE <delete_condition>]
    WHEN NOT MATCHED THEN
        INSERT (col1,col2,...)
        values(value1,value2,...)
        WHERE <insert_condition>;
#+end_src
* Data Control Language
Some DCL Commands:
- ~COMMIT~
- ~ROLLBACK~
- ~SAVEPOINT~
- ~GRANT~
- ~REVOKE~
* Others
** ~CASE~
#+begin_src sql
CASE e
    WHEN e1 THEN
          r1
    WHEN e2 THEN
          r2
    WHEN en THEN
          rn
    [ ELSE r_else ]
END
#+end_src
** ~EXECUTE~
To execute a stored procedure, use statement
#+begin_src sql
EXEC YourStoredProcedure(
        value1,
        value2,
        value3
);
#+end_src

To create a stored procedure, use [[*Stored Procedure][Stored Procedure]].
** Variables
** Virtual Columns
A virtual column is a table column whose values are calculated automatically
using other column values, or another deterministic expression.

#+begin_src sql
column_name [data_type] [GENERATED ALWAYS] AS (expression) [VIRTUAL]
#+end_src
* Useful Functions
** ~DECODE()~
#+begin_src sql
DECODE(expr, search1, result1, search2, result2, [default])
#+end_src

~DECODE~ compares ~expr~ to each ~search~ value one by one. If ~expr~ is
equal to a ~search~, then Oracle Database returns the corresponding ~result~.
If no match is found, then Oracle returns ~default~. If ~default~ is omitted,
then Oracle returns ~null~.
** ~NVL()~ or ~IFNULL()~
Function ~NVL()~ is for /Oracle/, and ~IFNULL~ is for /MySQL/ and /SQL Server/.
#+begin_src sql
/* In Oracle */
NVL(expr, return_value)

/* Or in MySQL */
IFNULL(expr, return_value)
#+end_src
The function lets you replace ~null~ (returned as a blank) with a string in
the results of a query. If ~expr~ is null, then the function returns ~return_value~.
If ~expr~ is not ~null~, returns ~expr~.
** ~SUBSTR()~ Family
#+begin_src sql
SUBSTR(char, position, substring_length)
#+end_src
The ~SUBSTR~ functions return a portion of char, beginning at character
~position~, ~substring_length~ characters long. ~SUBSTR~ calculates lengths using
characters as defined by the input character set:

- SUBSTRB uses bytes instead of characters
- SUBSTRC uses Unicode complete characters
- SUBSTR2 uses UCS2 code points
- SUBSTR4 uses UCS4 code points

Here are some other rules:

- If ~position~ is ~0~, then it is treated as ~1~.
- If ~position~ is positive, then /Oracle Database/ counts from the beginning
  of char to find the first character.
- If ~position~ is negative, then /Oracle/ counts backward from the end of char.
- If ~substring_length~ is omitted, then /Oracle/ returns all characters to the
  end of char. If ~substring_length~ is less than ~1~, then Oracle returns ~null~.
* Footnotes

[fn:1] [[https://dev.mysql.com/doc/refman/8.0/en/precision-math-decimal-characteristics.html][More Info]]

[fn:2] Timestamps range from 1970-01-01 00:00:01 to 2038-01-19 03:14:17.

[fn:3] The full command is =CREATE DATABASE [IF NOT EXISTS] NAME
[DEFAULT CHARSET] [COLLATE];=

[fn:4] The full command is
#+begin_src sql
CREATE TABLE name(
column1 datatype [COMMENT ...],
column2 datatype [COMMENT ...],
...
column_n datatype [COMMENT ...]
) [COMMENT ...];
#+end_src
